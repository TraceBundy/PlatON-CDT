#pragma once
#include "platon/crypto/bn256/zk/pairing.hpp"
namespace platon {
namespace crypto {
namespace bn256 {
namespace zk {
class Verifier {
 public:
  struct VerifyingKey {
    G1 alpha;
    G2 beta;
    G2 gamma;
    G2 delta;
    G1 gamma_abc[3];
  };
  struct Proof {
    G1 a;
    G2 b;
    G1 c;
  };
  VerifyingKey GetVerifyingKey() {
    return VerifyingKey{
        G1{"11404571630774432426361478696451104326160645828985583931760367249611771063312"_uint256,
           "20553728262460398718546122925307654056916758466027663757540819413674249770342"_uint256},
        G2("18886261668269822257916643071234180104569081751552650893053204340855219932672"_uint256,
           "19586707639445201077349322307912135652943077186638600557800879154597443163583"_uint256,
           "17149110734940438766192415532159844364369897737664281577035702099208977874320"_uint256,
           "13415683567289405620191194697785539783673337670298646871108458308628028620311"_uint256),
        G2("410325873763362685263453102209650051447014690236615374210506008103838135855"_uint256,
           "480740337502672518896766275936381646414499423445333888255393545520576455922"_uint256,
           "8669149964369931821021310851377052171702351789084710110193162507589879114001"_uint256,
           "2677725077079384599346557630428253762129541660286518807422982489542949928257"_uint256),
        G2("5532667349215989963770496936461671427088945655865436930388634752918468626338"_uint256,
           "2882460526476434201282496870195358123288995304693305152725586922527008950354"_uint256,
           "8539085216720969186381215146072580032273858133052949508714688213593304472198"_uint256,
           "17597657386825226434117339620558022661636510496585419233667372138731186526594"_uint256),
        //        vk.gamma_abc = new G1[3];
        {G1{"14009039398155720505150269708790661333297837075728094920382828224942856766144"_uint256,
            "20930955662491267233397107828124586351105651506146609020125271365893061173293"_uint256},
         G1{"5851231919488061643454688318825712062697499020691897643701372875390621893321"_uint256,
            "16233473441361394560431684535997736703822957284610781662173469397325430267528"_uint256},
         G1{"1385197555366316638547884976923676458145592326878252587889427394007889814716"_uint256,
            "2352687799100231607798767035998150582166744960824007121429034459320835851722"_uint256}}};
  }

  std::uint256_t Verify(const std::uint256_t input[], size_t len,
                        const Proof &proof) {
    std::uint256_t snark_scalar_field =
        "21888242871839275222246405745257275088548364400416034343698204186575808495617"_uint256;
    VerifyingKey vk = GetVerifyingKey();
    // Compute the linear combination vk_x
    G1 vk_x = G1{0, 0};
    for (int i = 0; i < len; i++) {
      G1 p2 = pairing::ScalarMul(vk.gamma_abc[i + 1], input[i]);
      vk_x = pairing::Addition(
          vk_x, pairing::ScalarMul(vk.gamma_abc[i + 1], input[i]));
    }
    vk_x = pairing::Addition(vk_x, vk.gamma_abc[0]);

    if (!pairing::PairingProd4(proof.a, proof.b, pairing::Negate(vk_x),
                               vk.gamma, pairing::Negate(proof.c), vk.delta,
                               pairing::Negate(vk.alpha), vk.beta))
      return 1;
    return 0;
  }

  bool VerifyTx(const std::uint256_t a[2], const std::uint256_t b[2][2],
                const std::uint256_t c[2], const std::uint256_t input[2]) {
    Proof proof{G1{a[0], a[1]}, G2(b[0][0], b[0][1], b[1][0], b[1][1]),
                G1{c[0], c[1]}};

    return Verify(input, 2, proof) == 0;
  }
};
}  // namespace zk
}  // namespace bn256
}  // namespace crypto
}  // namespace platon
