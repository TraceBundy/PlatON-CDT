#undef NDEBUG
#include <platon/platon.hpp>

using namespace platon;

/**
 *
 * 1. RANDAO does make random numbers difficult to predict, and random numbers
 * enjoy the same activity as the underlying consensus protocol, but the
 * attacker can drag it to At the end of the Reveal (disclosure) stage, decide
 * whether to reveal your commitment. Although there is a pledge loss, there is
 * a motivation to attack if the return is higher.
 * 2. You can use VDF to replace the last exclusive OR operation and change it
 * to an operation whose execution time must be longer than the waiting period
 * for the random number disclosure of each party. If the time to calculate the
 * final result is longer than the waiting period for the disclosure of the
 * random number, then even the last-minute submitter cannot know the result of
 * the random number, and the result of the operation is impossible to talk
 * about.
 *
 */

//  Random number generation algorithm
CONTRACT Randao : public platon::Contract {
 public:
  struct Participant {
    u128 secret;
    std::array<uint8_t, 32> commitment;
    u128 reward;
    bool revealed;
    bool rewarded;
    PLATON_SERIALIZE(Participant,
                     (secret)(commitment)(reward)(revealed)(rewarded))
  };

  struct Consumer {
    platon::Address caddr;
    platon::u128 bountypot;
    PLATON_SERIALIZE(Consumer, (caddr)(bountypot))
  };

  struct Campaign {
    uint64_t burn_num;
    u128 deposit;
    uint16_t commit_balkline;
    uint16_t commit_deadline;

    u128 random;
    bool settled;
    platon::u128 bountypot;
    uint32_t commit_num;
    uint32_t reveals_num;
    std::map<platon::Address, Consumer> consumers;
    std::map<platon::Address, Participant> participants;
    std::map<std::array<uint8_t, 32>, bool> commitments;
    PLATON_SERIALIZE(Campaign,
                     (burn_num)(deposit)(commit_balkline)(commit_deadline)(
                         random)(settled)(bountypot)(commit_num)(reveals_num)(
                         consumers)(participants)(commitments))
  };

 public:
  platon::StorageType<"numCampaigns"_n, u128> numCampaigns;
  platon::StorageType<"campaigns"_n, std::vector<Campaign>> campaigns;
  platon::StorageType<"founder"_n, platon::Address> founder;

 public:
  // campaignID, from, bnum, deposit, commitBalkline, commitDeadline, bountypot
  PLATON_EVENT2(LogCampaignAdded, u128, platon::Address, uint64_t, u128,
                uint16_t, uint16_t, platon::u128);

  // CampaignId, from, bountypot
  PLATON_EVENT2(LogFollow, u128, platon::Address, u128);

  // CampaignId, from, commitment
  using bytes32 = std::array<uint8_t, 32>;
  PLATON_EVENT2(LogCommit, u128, platon::Address, bytes32);

  // CampaignId, from, secret
  PLATON_EVENT2(LogReveal, u128, platon::Address, u128);

 public:
  ACTION void init() { founder.self() = platon_caller(); }

  /**
   * @brief For the random number demander, if you want to generate random
   * numbers, you first need to create a new round of activities, you need to
   * use For the NewCampaign function, for example, the current block height is
   * 1840602, and we need a random number in the 1840900 block, and we hope that
   * each participant submits a deposit of 20, and starts submitting 200 blocks
   * before the target block (that is, starting from block 1840700, including
   * 1840700) , The submission ends at the first 100 blocks of the target block
   * (that is, the 1840800 block ends, including 1840800 blocks). After 1840800
   * (not including 1840800) and before 1840900 (not including 1840900), it
   * belongs to the Reveal stage and can be called as follows:
   * NewCampaign(1840700, 20000000000000000000, 200, 100), and can be sent as a
   * participant reward fee.
   *
   * @param burn_num Target block height generated by random number
   * @param deposit Deposit required by participants
   * @param commit_balkline The distance from the start of submission to the
   * target block
   * @param commit_deadline The distance from the end of the submission to the
   * target block
   *
   * @return Activity ID number
   *
   */
  ACTION u128 NewCampaign(uint64_t burn_num, const u128 &deposit,
                          uint16_t commit_balkline, uint16_t commit_deadline) {
    // check parameter
    if (platon_block_number() >= burn_num) platon_revert();
    if (commit_balkline <= 0 || commit_deadline <= 0) platon_revert();
    if (commit_deadline > commit_balkline) platon_revert();
    if (platon_block_number() > burn_num - commit_balkline) platon_revert();
    if (deposit <= u128(0)) platon_revert();

    // generate a new campaign
    u128 campaign_id = campaigns.self().size() + 1;
    campaigns.self().push_back(Campaign());
    Campaign &one = campaigns.self().back();
    one.burn_num = burn_num;
    one.deposit = deposit;
    one.commit_balkline = commit_balkline;
    one.commit_deadline = commit_deadline;
    one.bountypot = platon_call_value();

    one.consumers[platon_caller()] =
        Consumer{platon_caller(), platon_call_value()};

    // emit event
    PLATON_EMIT_EVENT2(LogCampaignAdded, campaign_id, platon_caller(), burn_num,
                       deposit, commit_balkline, commit_deadline,
                       platon_call_value());

    DEBUG("campaign_id", campaign_id, "form", platon_caller().toString(),
          "burn_num", burn_num, "deposit", deposit, "commit_balkline",
          commit_balkline, "commit_deadline", commit_deadline, "bountypot",
          platon_call_value());

    return campaign_id;
  }

  /**
   * @brief
   * The random number demander can choose not to create a round of activity,
   * but choose to follow a certain round of random number activity as its own
   * random number. Then you can use the Follow function to follow the activity.
   * It must be carried out during or before the random number submission
   * window, otherwise it will Will fail. Take the previous example as an
   * example, the follow activity must be selected before 1840800 block
   * (including 1840800). The same event can send the main currency as a reward
   * fee for the participants
   *
   * @param campaign_id Existing event id
   *
   */
  ACTION void Follow(u128 campaign_id) {
    // check parameter
    if (campaign_id > u128(campaigns.self().size())) platon_revert();

    Campaign &one = campaigns.self()[int(campaign_id - u128(1))];
    if (platon_block_number() > one.burn_num - one.commit_deadline)
      platon_revert();

    auto iter = one.consumers.find(platon_caller());
    if (iter != one.consumers.end()) platon_revert();

    one.bountypot += platon_call_value();
    one.consumers[platon_caller()] =
        Consumer{platon_caller(), platon_call_value()};
    PLATON_EMIT_EVENT2(LogFollow, campaign_id, platon_caller(),
                       platon_call_value());

    DEBUG("campaign_id", campaign_id, "from", platon_caller().toString(),
          "bountypot", platon_call_value());
  }

  /**
   * @brief Participants can participate in the generation of random numbers by
   * submitting random numbers. To submit random numbers, they can call the
   * Commit function to submit a deposit to the contract. It cannot be more or
   * less than the activity deposit, and must be exactly equal to it. The random
   * number submission must be submitted during the random number submission
   * window, otherwise it will fail. Take the previous example as an example,
   * the window period for submitting random numbers is: 1840700 to 1840800
   *
   * @param campaign_id Existing event id
   * @param hs The sh3 value of the random number
   *
   */
  ACTION void Commit(u128 campaign_id, const bytes32 &hs) {
    // check parameter
    if (campaign_id > u128(campaigns.self().size())) platon_revert();
    Campaign &one = campaigns.self()[int(campaign_id - u128(1))];

    if (platon_block_number() < one.burn_num - one.commit_balkline)
      platon_revert();
    if (platon_block_number() > one.burn_num - one.commit_deadline)
      platon_revert();

    auto iter = one.participants.find(platon_caller());
    if (iter != one.participants.end()) platon_revert();

    auto iter_cmt = one.commitments.find(hs);
    if (iter_cmt != one.commitments.end()) platon_revert();

    one.participants[platon_caller()] = Participant{0, hs, false, false};
    one.commit_num++;
    one.commitments[hs] = true;

    PLATON_EMIT_EVENT2(LogCommit, campaign_id, platon_caller(), hs);

    DEBUG("campaign_id", campaign_id, "from", platon_caller().toString(), "hs",
          toHex(hs));
  }

  /**
   * @brief Disclosure of random numbers After the completion of the random
   * number submission phase, it enters the Reveal phase. The random number
   * submitter can disclose his random number, and the contract verifies whether
   * it is a valid random number. If it is valid, it will be calculated into the
   * final random number result. Taking the previous example as an example, the
   * random number disclosure window period is: 1840800 to 1840900
   *
   * @param campaign_id Existing event id
   * @param s random number
   *
   */
  ACTION void Reveal(u128 campaign_id, u128 s) {
    // check parameter
    if (campaign_id > u128(campaigns.self().size())) platon_revert();
    Campaign &cam = campaigns.self()[int(campaign_id - u128(1))];

    auto iter = cam.participants.find(platon_caller());
    if (iter == cam.participants.end()) platon_revert();
    Participant &pat = cam.participants[platon_caller()];

    // check secret
    std::vector<uint8_t> temp;
    temp.resize(32);
    toBigEndian(s, temp);
    bytes32 result;
    platon_sha3(&temp[0], temp.size(), &result[0], 32);
    DEBUG("temp", toHex(result));
    if (result != pat.commitment) platon_revert();

    if (pat.revealed) platon_revert();

    pat.secret = s;
    pat.revealed = true;

    cam.reveals_num++;
    cam.random ^= pat.secret;

    PLATON_EMIT_EVENT2(LogReveal, campaign_id, platon_caller(), s);

    DEBUG("campaign_id", campaign_id, "from", platon_caller().toString(), "s",
          std::to_string(s))
  }

  /**
   * @brief Obtaining a random number Anyone can obtain the random number of the
   * round of activities after the random number of the target number of blocks.
   * Only when all the random numbers submitted by all random number submitters
   * have been collected, will this round of random number generation be
   * considered valid. Participants who did not submit random numbers during the
   * collection phase will be fined for their deposits and distributed evenly to
   * other participants
   *
   * @param campaign_id Existing event id
   *
   */
  CONST u128 GetRandom(u128 campaign_id) {
    // check parameter
    if (campaign_id > u128(campaigns.self().size())) platon_revert();
    Campaign &cam = campaigns.self()[int(campaign_id - u128(1))];

    if (platon_block_number() < cam.burn_num) platon_revert();

    if (cam.reveals_num == cam.commit_num) {
      return cam.random;
    } else {
      platon_revert();
    }

    return u128(0);
  }

  /**
   * @brief Obtaining rewards and deposits After the target block, the random
   * number submitter can withdraw his deposit and income. If the random number
   * is generated successfully, the reward fee will be divided equally and the
   * deposit will be returned. If the random number generation fails, the
   * deposit of the participants who did not disclose the random number will be
   * divided equally, and the deposit of the participants who disclosed the
   * random number will be returned. If the random number generation fails and
   * no one successfully discloses the random number, all participants can get
   * their deposit back
   *
   * @param campaign_id Existing event id
   *
   */
  u128 CalculateShare(const Campaign &cam) {
    u128 result;
    if (cam.commit_num > cam.reveals_num) {
      result = u128(cam.commit_num - cam.reveals_num) * cam.deposit /
               u128(cam.reveals_num);
    } else {
      result = cam.bountypot / cam.reveals_num;
    }

    return result;
  }

  void ReturnReward(const u128 &share, const Campaign &cam, Participant &pat) {
    pat.reward = share;
    pat.rewarded = true;

    uint8_t addr[20];
    platon_caller(addr);

    u128 result = share + u128(cam.deposit);
    std::vector<uint8_t> temp;
    temp.resize(32);
    toBigEndian(result, temp);

    platon_transfer(addr, &temp[0], temp.size());
  }

  ACTION void GetMyBounty(u128 campaign_id) {
    // check parameter
    if (campaign_id > u128(campaigns.self().size())) platon_revert();
    Campaign &cam = campaigns.self()[int(campaign_id - u128(1))];

    auto iter = cam.participants.find(platon_caller());
    if (iter == cam.participants.end()) platon_revert();
    Participant &pat = cam.participants[platon_caller()];

    if (platon_block_number() < cam.burn_num) platon_revert();

    if (pat.rewarded) platon_revert();

    DEBUG("rewarded")

    if (cam.reveals_num > 0) {
      if (pat.revealed) {
        u128 share = CalculateShare(cam);
        ReturnReward(share, cam, pat);
      }
    } else {
      ReturnReward(0, cam, pat);
    }
  }

  /**
   * @brief Refund of bonuses If this round of random number generation fails,
   * the random number demander can return the submitted rewards through the
   * RefundBounty function
   *
   * @param campaign_id Existing event id
   *
   */
  ACTION void RefundBounty(u128 campaign_id) {
    // check parameter
    if (campaign_id > u128(campaigns.self().size())) platon_revert();
    Campaign &cam = campaigns.self()[int(campaign_id - u128(1))];

    if (platon_block_number() < cam.burn_num) platon_revert();

    if (cam.commit_num == cam.reveals_num && cam.commit_num != 0)
      platon_revert();

    if (cam.consumers[platon_caller()].caddr != platon_caller())
      platon_revert();

    u128 bountypot = cam.consumers[platon_caller()].bountypot;
    cam.consumers[platon_caller()].bountypot = 0;

    uint8_t addr[20];
    platon_caller(addr);

    auto func = [](std::vector<uint8_t> &result, uint8_t one) {
      result.push_back(one);
    };
    std::vector<uint8_t> temp;
    temp.resize(32);
    toBigEndian(bountypot, temp);
  }
};

PLATON_DISPATCH(Randao, (init)(NewCampaign)(Follow)(Commit)(Reveal)(GetRandom)(
                            GetMyBounty)(RefundBounty))